#+TITLE: Gunnar Wrobel's Emacs configuration
#+OPTIONS: toc:4 h:4

* Emacs configuation

** Global settings

*** Import basic settings

Set some basic information by copying =defaults.el= to =user.el= and adapting the variables set within the file.

The folling part loads the =defaults.el= file (as a safeguard) as well as the =user.el= file that should overwrite all values from =defaults.el=: 

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-settings-defaults-file (expand-file-name "defaults.el" user-emacs-directory))
  (load user-settings-defaults-file)
  (setq user-settings-file (expand-file-name "user.el" user-emacs-directory))
  (if (file-exists-p user-settings-file)
      (load user-settings-file))
  (setq user-secrets-file (expand-file-name "secrets.el" user-emacs-directory))
  (if (file-exists-p user-secrets-file)
      (load user-secrets-file))
#+END_SRC

Provide the settings as org-mode values:

#+name: user-settings-name
#+BEGIN_SRC emacs-lisp :tangle yes
user-settings-name
#+END_SRC

#+name: user-settings-email
#+BEGIN_SRC emacs-lisp :tangle yes
user-settings-email
#+END_SRC

#+name: user-settings-gpg-key-id
#+BEGIN_SRC emacs-lisp :tangle yes
user-settings-gpg-key-id
#+END_SRC

*** Personal information

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name user-settings-name
      user-mail-address user-settings-email)
#+END_SRC

*** Handling the Emacs custom file

Set up the customize file to its own separate file, instead of saving customize settings in init.el.

#+begin_src emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(if (file-exists-p custom-file)
(load custom-file))
#+END_SRC

*** Environment

**** Set the PATH for executables

~exec-path-from-shell~ makes the command-line path with Emacs's shell
match the same one on macOS.

#+begin_src emacs-lisp :tangle yes :results silent
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :init
  (exec-path-from-shell-initialize))
#+end_src


*** Keys

**** Mac OS settings

On a Mac I switch CAPS LOCK with control:

[[./images/global_keys_mac_modifier_keys.png]]

In addition I enable direct access to function keys:

[[./images/global_keys_mac_keys.png]]

Some typical Mac shortcuts I set:


[[./images/global_keys_mac_shortcuts_dock.png]]

[[./images/global_keys_mac_shortcuts_mission_control.png]]

[[./images/global_keys_mac_shortcuts_screenshots.png]]

[[./images/global_keys_mac_shortcuts_spotlight.png]]

**** Mac OS: Emacs modifier keys

I reorder the Mac OS special keys so that I can use the left command key as an access key to the relatively sparse hyper keymaps so that I can add all my own key combinations there:

#+begin_src emacs-lisp :tangle yes
  (when (string-equal system-type "darwin")
    ;; Make the easiest command key the hyper key to allow to provide room for my own user keys within the hyper space
    (setq ns-command-modifier 'hyper)
    ;; Move meta from option to right command
    (setq ns-right-command-modifier 'meta)
    ;; Free the option key from any special function to get access to special characters
    (setq ns-option-modifier 'none)
    ;; Move super from left command to right option
    (setq ns-right-option-modifier 'super)
    ;; Actually unchanged (and CAPS LOCK on my Mac OS - see above)
    (setq ns-control-modifier 'control)
    ;; Provide alt key on function
    (setq ns-function-modifier 'alt))
#+END_SRC

**** Hyper key maps

I used the hyper key space initially to get my own set of key
combinations that I use pretty often.

***** Keymaps

#+begin_src emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  KEYMAPS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; define a var for your keymap, so that you can set it as local map
;; (meaning, active only when your mode is on)
(defvar my-generic-map nil "Keymap for additional generic commands in emacs")
(defvar non-programming-map nil "Keymap for additional non-programming commands in emacs")
(defvar my-programming-map nil "Keymap for additional programming commands in emacs")
(defvar magit-programming-map nil "Keymap for additional magit commands in emacs")
(defvar whitespace-programming-map nil "Keymap for additional movement commands in emacs")
(defvar js-programming-map nil "Keymap for additional commands during javascript programming")
#+END_SRC

***** First level

These are the quick access keys that can be used while holding down the command key.

****** Editing

Quick, standard editing commands:

#+begin_src emacs-lisp :tangle yes :results silent
(global-set-key (kbd "H-u") 'backward-delete-char-untabify)
(global-set-key (kbd "H-U") 'backward-kill-word)
(global-set-key (kbd "H-o") 'delete-char)
(global-set-key (kbd "H-O") 'kill-word)
(global-set-key (kbd "H-v") 'yank)
(global-set-key (kbd "H-x") 'kill-region)
(global-set-key (kbd "H-c") 'kill-ring-save)
(global-set-key (kbd "H-q") 'fill-paragraph)
(global-set-key (kbd "H-s") 'save-buffer)
(global-set-key (kbd "H-z") 'undo)
#+END_SRC

****** Files and buffers

Quick, standard access commands:

#+begin_src emacs-lisp :tangle yes :results silent
(global-set-key (kbd "H-f") 'find-file)
(global-set-key (kbd "H-b") 'switch-to-buffer)
(global-set-key (kbd "H-d") 'kill-this-buffer)
#+END_SRC


***** Second level

#+begin_src emacs-lisp :tangle yes :results silent
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;  Generic emacs commands
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; definition for your keybinding and menu
  (when (not my-generic-map) ;; if it is not already defined
    ;; assign command to keys
    (setq my-generic-map (make-sparse-keymap))
    (define-key my-generic-map (kbd "a") 'beginning-of-line)
    (define-key my-generic-map (kbd "e") 'end-of-line)

    (define-key my-generic-map (kbd "k") 'kill-this-buffer)
    (define-key my-generic-map (kbd "o") 'my-next-window)
    (define-key my-generic-map (kbd "p") 'my-previous-window)
    (define-key my-generic-map (kbd "ä") 'my-skip-four-windows)
    (define-key my-generic-map (kbd "s") 'save-buffer)
    (define-key my-generic-map (kbd "i") 'switch-to-buffer)
    (define-key my-generic-map (kbd "f") 'find-file)
    (define-key my-generic-map (kbd "C-s") 'write-file)

    (define-key my-generic-map (kbd "C-c") 'save-buffers-kill-terminal)
   
    (define-key my-generic-map (kbd "0") 'delete-window)

    (define-key my-generic-map (kbd "g") 'keyboard-quit)

    (define-key my-generic-map (kbd "ö") 'yank)
    (define-key my-generic-map (kbd "v") 'yank)
    (define-key my-generic-map (kbd "u") 'undo-tree-visualize)
    (define-key my-generic-map (kbd "C-w") 'kill-region)
    (define-key my-generic-map (kbd "x") 'kill-region)
    (define-key my-generic-map (kbd "C-ö") 'backward-kill-word)
    (define-key my-generic-map (kbd "w") 'kill-ring-save)
    (define-key my-generic-map (kbd "c") 'kill-ring-save)
    (define-key my-generic-map (kbd "q") 'fill-paragraph)

    (define-key my-generic-map (kbd "h") help-map))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;  Non programming mode stuff
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defvar slack-non-programming-map nil "Keymap for slack commands in emacs")

  (when (not slack-non-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq slack-non-programming-map (make-sparse-keymap)))

  (defvar help-non-programming-map nil "Keymap for help commands in emacs")

  (when (not help-non-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq help-non-programming-map (make-sparse-keymap)))

  ;; definition for your keybinding and menu
  (when (not non-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq non-programming-map (make-sparse-keymap))
    (define-key non-programming-map (kbd "g") 'grep)
    (define-key non-programming-map (kbd "c") 'calc)
    (define-key non-programming-map (kbd "j") 'jabber-connect)
    (define-key non-programming-map (kbd "o") 'org-agenda-list)
    (define-key non-programming-map (kbd "p") 'package-list-packages)
    (define-key non-programming-map (kbd "n") 'nodejs-repl)
    (define-key non-programming-map (kbd "s") slack-non-programming-map)
    (define-key non-programming-map (kbd "h") help-non-programming-map))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;  My programming mode stuff
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; definition for your keybinding and menu
  (when (not magit-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq magit-programming-map (make-sparse-keymap)))

  ;; definition for your keybinding and menu
  (when (not whitespace-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq whitespace-programming-map (make-sparse-keymap))
    (define-key whitespace-programming-map (kbd "w") 'whitespace-mode)
    (define-key whitespace-programming-map (kbd "c") 'whitespace-cleanup))

  ;; definition for your keybinding and menu
  (when (not js-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq js-programming-map (make-sparse-keymap))
    (define-key js-programming-map (kbd "e") 'local-eslint-fix)
    (define-key js-programming-map (kbd "j") 'jest-test-file)
    (define-key js-programming-map (kbd "u") 'jest-update-file)
    (define-key js-programming-map (kbd "m") 'mocha-test-file)
    (define-key js-programming-map (kbd "a") 'mocha-test-project))

  ;; definition for your keybinding and menu
  (when (not my-programming-map) ;; if it is not already defined
    ;; assign command to keys
    (setq my-programming-map (make-sparse-keymap))
    (define-key my-programming-map (kbd ";") 'comment-region)
    (define-key my-programming-map (kbd ",") 'uncomment-region)
    (define-key my-programming-map (kbd "i") 'indent-region)
    (define-key my-programming-map (kbd "RET") 'eval-region)
    (define-key my-programming-map (kbd "d") 'set-personal-variable-debug-on-error)
    (define-key my-programming-map (kbd "g") magit-programming-map)
    (define-key my-programming-map (kbd "w") whitespace-programming-map))
    (define-key my-programming-map (kbd "j") js-programming-map)

  (global-set-key (kbd "H-ö") my-generic-map)
  (global-set-key (kbd "H-+") non-programming-map)
  (global-set-key (kbd "H-#") my-programming-map)
#+END_SRC

**** Key frequencies

I use keyfreq to look at the keys I use and optimize key bindings for
that usage:

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package keyfreq
    :ensure t
    :bind
    (:map non-programming-map ("k" . keyfreq-show))
    :config
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src

**** Unbound keys

Use the [[http://melpa.org/#/unbound][unbound]] package to handle/display unbound keys:

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package unbound
    :commands describe-unbound-keys
    :ensure t
    :bind
    (:map non-programming-map ("K" . describe-unbound-keys))
    :config
    (setq unbound-modifiers '(control meta shift super hyper alt))

    (defun key-complexity-1 (key)           ; key:=(modifiers... key)
      ;; Was "1"; But for me Control is the left pinky and I
      ;; consider it to be of higher complexity than hyper
      (+ (if (memq 'control key) 2 0)
         ;; Was "2"; But for me Meta is the right thumb and I
         ;; consider it to be of higher complexity
         (if (memq 'meta key) 4 0)
         ;; Was "3"; But if Control is 2, then Shift (one below on the
         ;; pinky) is fine with "2" as well
         (if (memq 'shift key) 2 0)
         (if (memq 'super key) 4 0)
         ;; Was "4"; But for me Hyper is the left thumb and I
         ;; consider it to be low complexity
         (if (memq 'hyper key) 1 0)
         (if (memq 'alt key) 3 0)
         (* 2 (1- (length key)))
         (progn
           (setq key (car (last key)))
           (if (integerp key)
               (cond ((and (>= key ?a) (<= key ?z)) 0)
                     ;; Original comment: "capitals are weird" and
                     ;; the value was "6"; But I don't consider them
                     ;; "that" weird.
                     ((and (>= key ?A) (<= key ?Z)) 2)
                     ((and (>= key ?0) (<= key ?9)) 2)
                     ((memq key '(?\b ?\r ?\ )) 1)
                     ;; Unshifted punctuation (US keyboards)
                     ((memq key '(?` ?- ?= ?\t ?[ ?] ?\\ ?\; ?' ?, ?. ?/)) 3)
                     ;; Other letters -- presume that one's keyboard has them if
                     ;; we're going to consider binding them.
                     ((let (case-fold-search)
                        (string-match
                         "[016A]" (category-set-mnemonics
                                   (char-category-set key)))) 2)
                     (t 5))
             7)))))
#+end_src


*** Movement

**** Global keys

Quick, standard movement commands - these are the quick access keys
that can be used while holding down the command key.

#+begin_src emacs-lisp :tangle yes :results silent
(global-set-key (kbd "H-i") 'previous-line)
(global-set-key (kbd "H-k") 'next-line)
(global-set-key (kbd "H-j") 'left-char)
(global-set-key (kbd "H-l") 'right-char)
(global-set-key (kbd "H-SPC") 'set-mark-command)
(global-set-key (kbd "H-I") 'scroll-down-command)
(global-set-key (kbd "H-K") 'scroll-up-command)
(global-set-key (kbd "H-J") 'backward-word)
(global-set-key (kbd "H-L") 'forward-word)
(global-set-key (kbd "H-a") 'beginning-of-line)
(global-set-key (kbd "H-e") 'end-of-line)
#+END_SRC

**** Avy

[[https://github.com/abo-abo/avy][Avy]] allows to quickly jump to characters/words/lines:

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package avy
    :ensure t
    :demand t
    :load-path "site-lisp/avy"
    :bind
    (("H-h" . avy-goto-char)
     ("H-H" . avy-goto-char-2)
     ("H-C-h" . avy-goto-char-timer)
     ("H-g" . avy-goto-word-1)
     ("H-m" . avy-goto-line))
    :config
    (avy-setup-default))
#+END_SRC


*** Backups

By default, Emacs saves backup files in the current directory. These
are the files ending in ~ that are cluttering up your directory
lists. The following code stashes them all in ~/.backups:

#+begin_src emacs-lisp :tangle yes :results silent
(setq backup-directory "~/.backups")
(unless (file-directory-p backup-directory)
  (make-directory backup-directory))
(setq backup-directory-alist (list (cons "." backup-directory)))
#+END_SRC

Some basic backup settings that keeps a lot of backups around:

#+begin_src emacs-lisp :tangle yes :results silent
(setq backup-by-copying t    ; Don't delink hardlinks
      delete-old-versions -1 ; Do not clean up the backups
      version-control t)     ; Use version numbers on backups,
#+END_SRC

And I'm currently testing the [[https://github.com/antham/helm-backup][helm-backup]] package as an alternative
for keeping backups in git and getting easy access to them in case of
emergency:

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package helm-backup
    :ensure t
    :commands helm-backup
    :init
    (add-hook 'after-save-hook 'helm-backup-versioning)
    :bind ("H-B" . helm-backup))
#+END_SRC

As alternatives I looked at [[https://github.com/lewang/backup-walker][backup-walker]], [[https://github.com/chadbraunduin/backups-mode][backups-mode]] as well as
[[https://www.emacswiki.org/emacs/backup-each-save.el][backup-each-save]]. =helm-backup= looked most promising so far though.


*** History

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package session
    :ensure t
    :if (not noninteractive)
    :load-path "site-lisp/session/lisp"

    :config
    (add-hook 'after-init-hook 'session-initialize t))
#+END_SRC

*** Undo

People often struggle with the Emacs undo model, where there's really
no concept of "redo" - you simply undo the undo.

The undo tree mode - visualize your undos and branches lets you use
=C-x u= (=undo-tree-visualize=) to visually walk through the changes
you've made, undo back to a certain point (or redo), and go down
different branches.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** Help

Some quick keyboard access to describing function that I still use
frequently:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(define-key help-non-programming-map (kbd "f") 'describe-function)
(define-key help-non-programming-map (kbd "k") 'describe-key)
#+END_SRC


*** GUI
**** Minibuffer

***** yes-or-no

Get rid of yes-or-no questions - y or n is enough

#+begin_src emacs-lisp :tangle yes :results silent
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC


**** Window
***** Theme

I looked at various theme packages but found nothing that really
pleased my eyes so I finally settled on my old config. This just
selects a black background and a whity foreground. Otherwise it just
uses the default Emacs settings:

#+begin_src emacs-lisp :tangle yes :results silent
  (custom-set-faces
   '(font-lock-function-name-face
     ((((class color) (min-colors 8)) (:foreground "yellow" :weight bold))))
   '(default
      ((t
        (:background "black" :foreground "white" )))))
#+END_SRC

***** Font

Tell Emacs to use the font [[http://adobe-fonts.github.io/source-code-pro/][Source Code Pro]] (installed via Font Book
from [[https://github.com/adobe-fonts/source-code-pro/releases/tag/2.030R-ro%2F1.050R-it][this release]]):

#+begin_src emacs-lisp :tangle yes :results silent
(add-to-list 'default-frame-alist
             '(font . "Source Code Pro-14"))
#+end_src

#+RESULTS:

Display emojis. Source of system-specific fonts is in
[[https://github.com/syohex/emacs-ac-emoji][the README for the
emacs-ac-emoji package.]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(let ((font (if (= emacs-major-version 25)
                "Symbola"
              (cond ((string-equal system-type "darwin")    "Apple Color Emoji")
                    ((string-equal system-type "gnu/linux") "Symbola")))))
  (set-fontset-font t 'unicode font nil 'prepend))
#+END_SRC

***** No startup message

This message is not really interesting:

#+begin_src emacs-lisp :tangle yes :results silent
(setq-default inhibit-startup-message t)
#+end_src

**** Modeline

**** Windows
***** Shrink windows

Convenient keybindings to resize windows.

#+begin_src emacs-lisp :tangle yes :results silent
(bind-key "H-C-<left>"  'shrink-window-horizontally)
(bind-key "H-C-<right>" 'enlarge-window-horizontally)
(bind-key "H-C-<down>"  'shrink-window)
(bind-key "H-C-<up>"    'enlarge-window)
#+end_src

#+RESULTS:
: enlarge-window

***** Ace Window

[[https://github.com/abo-abo/ace-window][ace-window]] is a package that uses the same idea from ace-jump-mode for
buffer navigation, but applies it to windows. The default keys are
1-9, but it's faster to access the keys on the home row, so that's
what I have them set to (with respect to Dvorak, of course).

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package ace-window
    :ensure t
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?ö ?ä))
    (ace-window-display-mode)
    :bind
    ("H-n" . ace-window)
    ("H-N" . other-window))
#+end_src

***** Winner mode - undo and redo window configuration

[[https://www.emacswiki.org/emacs/WinnerMode][=winner-mode=]] lets you use =C-c <left>= and =C-c <right>= to switch
between window configurations. This is handy when something has popped
up a buffer that you want to look at briefly before returning to
whatever you were working on. When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(use-package winner
  :if (not noninteractive)
  :defer 5
  :ensure t
  :bind (("H-<left>" . winner-undo)
         ("H-<right>" . winner-redo))
  :config
  (winner-mode t))
#+END_SRC

**** Windmove - switching between windows

Windmove lets you move between windows with something more natural than cycling through =C-x o= (=other-window=).
Windmove doesn't behave well with Org, so we need to use different keybindings.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(use-package windmove
  :bind
  (("H-<end>" . windmove-right)
   ("H-<home>" . windmove-left)
   ("H-<prior>" . windmove-up)
   ("H-<next>" . windmove-down)
   ))
#+END_SRC

**** Clock in the modeline

I like having the clock.

#+begin_src emacs-lisp :tangle yes :results silent
(display-time-mode 1)
#+end_src

*** Encoding

Set the default file encoding:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
#+END_SRC

*** Git

git needs to be installed early in order to allow placing the password store under version control.

**** Installation

git is installed on MacOS via MacPorts:

#+begin_src sh
sudo port install git
#+end_src

**** Setup

Git should have a user name and email as described in a documentation about the [[https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup][initial git setup]]:

#+begin_src sh :var USER_SETTINGS_EMAIL=user-settings-email USER_SETTINGS_NAME=user-settings-name :results silent
git config --global user.name "$USER_SETTINGS_NAME"
git config --global user.email $USER_SETTINGS_EMAIL
git config --global --bool --add pass.signcommits true
git config --global github.user wrobel
git config --global api.github.com.user wrobel
#+end_src

This also enables signing all commits

** Secrets

*** GnuPG

**** Installation

GnuPG is installed on MacOS via MacPorts:

#+begin_src sh
sudo port install gnupg21
#+end_src

**** Key generation

The generation of a key is documented in the [[https://www.gnupg.org/howtos/de/GPGMiniHowto-3.html#ss3.1][GnuPG documentation]].

#+begin_src sh
gpg --gen-key
#+end_src

This is the corresponding output:

#+BEGIN_EXAMPLE
gpg (GnuPG) 2.1.23; Copyright (C) 2017 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

gpg: Verzeichnis `~/.gnupg' erzeugt
gpg: Die "Keybox" `~/.gnupg/pubring.kbx' wurde erstellt
Hinweis: "gpg --full-generate-key" ruft den erweiterten Dialog auf.

GnuPG erstellt eine User-ID, um Ihren Schlüssel identifizierbar zu machen.

Ihr Name ("Vorname Nachname"): Gunnar Wrobel
Email-Adresse: gunnar.wrobel@jobmatch.me
Sie haben diese User-ID gewählt:
    "Gunnar Wrobel <gunnar.wrobel@jobmatch.me>"

Ändern: (N)ame, (E)-Mail oder (F)ertig/(A)bbrechen? F
Wir müssen eine ganze Menge Zufallswerte erzeugen.  Sie können dies
unterstützen, indem Sie z.B. in einem anderen Fenster/Konsole irgendetwas
tippen, die Maus verwenden oder irgendwelche anderen Programme benutzen.
gpg: ~/.gnupg/trustdb.gpg: trust-db erzeugt
gpg: Schlüssel ABCXYZ ist als ultimativ vertrauenswürdig gekennzeichnet
gpg: Verzeichnis `~/.gnupg/openpgp-revocs.d' erzeugt
gpg: Widerrufzertifikat wurde als '~/.gnupg/openpgp-revocs.d/ABCXYZ.rev' gespeichert.
Öffentlichen und geheimen Schlüssel erzeugt und signiert.

pub   rsa2048 2017-08-26 [SC] [verfällt: 2019-08-26]
      ABCXYZ
uid                      Gunnar Wrobel <gunnar.wrobel@jobmatch.me>
sub   rsa2048 2017-08-26 [E] [verfällt: 2019-08-26]
#+END_EXAMPLE

*** pass

**** Installation

pass is installed on MacOS via MacPorts but it requires the gpg2 binary which is not compatible with the gpg binary the package =gnupg21= offers. As a workaround you can create a gpg2 link redirecting to gpg

#+begin_src sh
cd /opt/local/bin/
sudo ln -s gpg gpg2
sudo port install pass
#+end_src

**** Setup

The setup documentation can be found [[https://www.passwordstore.org][here]].

Simply initialize the store with the GnuPG key ID from the GnuPG setup above:

#+begin_src sh :var GNU_PG_KEY_ID=user-settings-gpg-key-id :results output
pass init $GNU_PG_KEY_ID
pass git init
pass git remote add origin git@gitlab.com:gwrobel/password-store.git
pass git push -u --all
#+end_src

#+RESULTS:
: Password store initialized for XYZ
: Leeres Git-Repository in ~/.password-store/.git/ initialisiert
: [master (Basis-Commit) 72ed975] Add current contents of password store.
:  1 file changed, 1 insertion(+)
:  create mode 100644 .gpg-id
: [master 0bb5284] Configure git repository for gpg file diff.
:  1 file changed, 1 insertion(+)
:  create mode 100644 .gitattributes

**** Browser integration

Downloaded [[https://github.com/dannyvankooten/browserpass/releases/download/1.0.6/browserpass-darwinx64.zip][Darwin x64 binary]] from [[https://github.com/dannyvankooten/browserpass/releases][here]].

Installation procedure (for the wrapper workaround see [[https://github.com/dannyvankooten/browserpass/issues/13][bug report)]]:

#+begin_src sh :results silent
cd ~/Downloads
test -d ~/bin || mkdir ~/bin
unzip browserpass-darwinx64.zip browserpass-darwinx64 -d ~/bin
#+end_src

#+begin_src sh :tangle ~/bin/browserpass-wrapper.sh :padline no :tangle-mode (identity #o755)
#!/bin/bash

if [ -f "${HOME}/.gpg-agent-info" ]
then
source ${HOME}/.gpg-agent-info
export GPG_AGENT_INFO
fi
export GPG_TTY="$(tty)"
export PATH="$PATH:/opt/local/bin"
~/bin/browserpass-darwinx64 "$@"
exit $?
#+end_src

#+begin_src sh :tangle "~/Library/Application Support/Google/Chrome/NativeMessagingHosts/com.dannyvankooten.browserpass.json" :padline no
{
  "name": "com.dannyvankooten.browserpass",
  "description": "Browserpass binary for the Chrome extension",
  "path": "/Users/gwjmm/bin/browserpass-wrapper.sh",
  "type": "stdio",
  "allowed_origins": [
    "chrome-extension://jegbgfamcgeocbfeebacnkociplhmfbk/",
    "chrome-extension://klfoddkbhleoaabpmiigbmpbjfljimgb/"
  ]
}
#+end_src

In addition you need to install the [[https://chrome.google.com/webstore/detail/browserpass/jegbgfamcgeocbfeebacnkociplhmfbk][browserpass chrome extension]].

**** Emacs support

Install the [[https://github.com/NicolasPetton/pass][=pass=]] package:

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package pass
    :ensure t
    :bind
    (
     :map non-programming-map
          ("P" . pass))
  )
#+END_SRC

Install the [[https://github.com/DamienCassou/auth-password-store][=auth-password-store=]] package:

#+begin_src emacs-lisp :tangle yes
(use-package auth-password-store
:ensure t
:init
(auth-pass-enable)
)
#+END_SRC

***** TODO Look at helm-pass https://github.com/jabranham/helm-pass

** Coding
*** Languages
**** Javascript
***** Node JS / nvm

Install [[https://nodejs.org/en/][Node JS]] via [[https://github.com/creationix/nvm][Node version manager]]:

#+begin_src sh
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash
nvm install --lts
#+end_src
***** js-mode

I'm happy with =js-mode= for my development. Seems to work fine for
the combination of ES6, Flowtype and React/JSX:

#+begin_src emacs-lisp :tangle yes :results silent
  (defun search-local-js-config ()
    (setq jssettings (concat (locate-dominating-file buffer-file-name ".emacs.js.el") ".emacs.js.el"))
    (if (file-readable-p jssettings)
        (progn
          (load jssettings))))

    (add-hook 'js-mode-hook
              (lambda ()
                (search-local-js-config)))
#+end_src
***** Eslint

Allow for local flycheck definitions for eslint:

#+begin_src emacs-lisp :tangle yes :results silent
(defmacro flycheck-define-local-eslint-checker (checker-symbol config-file-symbol checker-path config-file-path)
  `(progn
     (flycheck-def-config-file-var ,config-file-symbol ,checker-symbol ,config-file-path
       :safe #'stringp)
     (flycheck-define-checker ,checker-symbol
       "A JavaScript syntax and style checker using eslint. See URL `http://eslint.org'."
       :command ("node"
		 (eval ,checker-path)
		  "--format=checkstyle"
		  (config-file "--config" ,config-file-symbol)
		  source)
	:error-parser flycheck-parse-checkstyle
	:modes (js-mode js2-mode js3-mode web-mode))
	 (progn
	   (add-to-list 'flycheck-checkers ',checker-symbol)
	   (flycheck-select-checker ',checker-symbol)
	   (flycheck-mode))))
#+end_src

Use the =eslint-fix= package to quick fix files using Eslint. Since
=eslint-fix= is a rather small package and does not allow for a local
eslint (which I'm using always) I simply copied the =eslint-fix=
package content (the single =eslint-fix= function:

#+begin_src emacs-lisp :tangle yes :results silent
  (defun eslint-fix ()
    "Format the current file with ESLint."
    (interactive)
    (let (
          (local-eslint
           (concat (locate-dominating-file buffer-file-name "package.json")
                   "node_modules/.bin/eslint"))
          (eslint-executable
           (if (file-exists-p local-eslint)
               local-eslint
             (executable-find "eslint"))))
      (if (file-exists-p eslint-executable)
          (progn (call-process eslint-executable
                               nil
                               "*ESLint Errors*"
                               nil
                               "--fix"
                               buffer-file-name)
                 (revert-buffer t t t))
        (message "ESLint not found.")))))

  (define-key js-mode-map (kbd "A-l") 'eslint-fix)
#+end_src

***** Jest


***** React / jsx

Use web-mode for React / JSX files:

#+begin_src emacs-lisp :tangle yes :results silent
    (use-package web-mode
      :ensure t
      :mode "\\.jsx$"
      :config
      (defun react-web-mode-hook ()
        "Hooks for Web mode. Adjust indents"
        ;;; http://web-mode.org/
        (setq web-mode-markup-indent-offset 4)
        (setq web-mode-css-indent-offset 4)
        (setq web-mode-code-indent-offset 4)
        (setq indent-tabs-mode nil))

      (defadvice web-mode-highlight-part (around tweak-jsx activate)
        (if (equal web-mode-content-type "jsx")
            (let ((web-mode-enable-part-face nil))
              ad-do-it)
          ad-do-it))

      (add-hook 'web-mode-hook  'react-web-mode-hook)
      ;;(add-hook 'web-mode-hook (lambda ()
      ;;                    (init-flycheck-eslint)))
      )
#+end_src

I tested [[https://github.com/felipeochoa/rjsx-mode/issues][rjsx-mode]] but this is based on [[http://elpa.gnu.org/packages/js2-mode.html][js2-mode]] and the latter is
somewhat [[https://github.com/mooz/js2-mode/issues/224][problematic]] with flowtype (displays errors as it does not
parse flowtype annotations). js-mode seems to be more tolerant
there. Maybe I could tweak the js2-mode configuration to simply ignore
flowtype information but as I do not feel unhappy with the js-mode
setup I did not look further into that for now.

**** YAML

Use =yaml-mode= for =.yml= or =.yaml= files:

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package yaml-mode
    :mode "\\.ya?ml\\'"
    :ensure t)
#+end_src

*** Documentation

**** Markdown

Enable markdown:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package markdown-mode
    :ensure t
    :mode (("\\`README\\.md\\'" . gfm-mode)
           ("\\.md\\'"          . markdown-mode)
           ("\\.markdown\\'"    . markdown-mode))
    :config
    (add-hook 'markdown-mode-hook
              (lambda ()
                (visual-line-mode t)
                (writegood-mode t)
                (flyspell-mode t)))
    (setq markdown-command "pandoc --smart -f markdown -t html")
    (setq markdown-css-paths `(,(expand-file-name "markdown.css" (expand-file-name "vendor" user-emacs-directory))))
    (use-package markdown-preview-mode
      :ensure t))
#+END_SRC


*** Tools

**** Flycheck
#+begin_src emacs-lisp :tangle yes :results silent
  (use-package flycheck
    :ensure t)
  (use-package flycheck-color-mode-line
    :ensure t
    :config
    (eval-after-load "flycheck"
      '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
#+end_src

**** Magit

A great interface for git projects. It's much more pleasant to use
than the git interface on the command line. Use an =H-# g g= to
access magit.

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package magit
    :ensure t
    :commands magit-status
    :config
    (progn
      (magit-auto-revert-mode 1))
    :init
    (add-hook 'magit-mode-hook 'magit-load-config-extensions)
    :bind
    (
     :map magit-programming-map
          ("g" . magit-status)
          ("b" . magit-blame-mode)
          ("B" . magit-branches)))
#+end_src

A setup for fullscreen magit:

#+BEGIN_QUOTE
The following code makes magit-status run alone in the frame, and then
restores the old window configuration when you quit out of magit.

No more juggling windows after commiting. It's magit bliss.
#+END_QUOTE
[[http://whattheemacsd.com/setup-magit.el-01.html][Source: Magnar Sveen]]

#+begin_src emacs-lisp :tangle yes :results silent
;; full screen magit-status
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+end_src

***** magithub (currently disabled)

The package =magithub= provide access to [[github.com]] within emacs. This
relies on the helper package [[https://github.com/magit/ghub][ghub]] which needs a [[https://github.com/settings/tokens][developer token]] for
access to the [[https://api.github.com/][github API]]. I stored this token within the =pass= system
under "api.github.com" (as I have my normal password for github under
"github.com") and needed to fix the =ghub-instance= parameter to
"api.github.com" accordingly. The token is being pulled by the =ghub=
package (pull this from =melpa= and not from =melpa-stable=) using
=auth-password-store=. In addition =magithub= needs the git config
=api.github.com.user= set somewhere above. The default timeout of
three seconds was too slow on my machine.

#+begin_src emacs-lisp :tangle yes :results silent
  (use-package magithub
    :after magit
    :disabled t
    :init
     (setq ghub-instance "api.github.com")
     (setq magithub-api-timeout 30)
    :config
     (magithub-feature-autoinject t))
#+end_src

This has been to slow, so I disabled it.

** Org mode

*** Mode settings

Activate =flyspell= and =writegood-mode=:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (add-hook 'org-mode-hook
            (lambda ()
              (flyspell-mode)))
  (add-hook 'org-mode-hook
            (lambda ()
              (writegood-mode)))
#+END_SRC

*** org-agenda

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(load-library "find-lisp")
(setq org-agenda-files
   (find-lisp-find-files "~/org/active" "\.org$"))
#+END_SRC

*** org-babel

**** Supported languages

This initializes the set of languages =org-babel= supports:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(use-package ob-http
:ensure t
)

(setq org-ditaa-jar-path "~/.emacs.d/vendor/ditaa0_9.jar")

(org-babel-do-load-languages
 'org-babel-load-languages
 '((C . t)
   (calc . t)
   (ditaa . t)
   (dot . t)
   (http . t)
   (java . t)
   (js . t)
   (latex . t)
   (ledger . t)
   (lisp . t)
   (python . t)
   (R . t)
   (sh . t)
   (sqlite . t)))

(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC

   
** Tools

*** Shell

Easily create new shells:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package eshell
    :ensure t
    :bind
    (:map non-programming-map ("e" . eshell-new))
    :config
    (defun eshell-new ()
      "Open a new eshell"
      (interactive)
      (eshell t)))
#+END_SRC

*** Browser

Make sure we always rename the EWW buffer to get several of those
(similar to tabs):

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package eww
    :ensure t
    :bind
    (:map non-programming-map ("b" . eww))
    :config
    ;; Auto-rename new eww buffers
    (defun rename-eww-hook ()
      "Rename eww browser's buffer so sites open in new page."
      (rename-buffer "eww" t))
    (add-hook 'eww-mode-hook #'rename-eww-hook))
#+END_SRC

Also use the [[https://www.emacswiki.org/emacs/eww-lnum][=eww-lnum=]] package to allow following links quickly:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package eww-lnum
    :ensure t
    :config
    (bind-key "f" #'eww-lnum-follow eww-mode-map)
    (bind-key "F" #'eww-lnum-universal eww-mode-map))
#+END_SRC

*** Writing

**** ispell

Ignore =org-babel= source blocks:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
#+END_SRC

**** flyspell

NO spell check for embedded snippets:

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let* ((rlt ad-return-value)
         (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (case-fold-search t)
         b e)
    (when ad-return-value
      (save-excursion
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t))))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

*** Helper modes

**** writegood-mode

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
    (use-package writegood-mode
      :ensure t)
#+END_SRC

** Communication

*** Slack

Followed procedure at https://github.com/yuya373/emacs-slack



#+BEGIN_SRC emacs-lisp :tangle yes :results silent
    (use-package slack
      :ensure t
      :init
      (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
      (setq slack-prefer-current-team t)
      :bind
      (:map slack-non-programming-map
            ("s" . slack-start)
            ("r" . slack-select-unread-rooms)
            ("t" . slack-select-unread-threads)
            ("R" . slack-select-room))
      :config
      (slack-register-team
       :name "truck-pro"
       :default t
       :client-id secret-slack-tp-client-id
       :client-secret secret-slack-tp-client-secret
       :token secret-slack-tp-token
       :subscribed-channels '(general random liveprodukt)))
#+END_SRC

**** TODO Convert slack-register-team to a personal team list configurable in secrets.el

*** Alert

Useful for growl-like notifications (but you need the unstable =melpa= version hence a package pinned to melpa):

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package alert
  :ensure t
  :commands (alert)
  :init
  (setq alert-default-style 'osx-notifier)
  (setq alert-log-messages t))
#+END_SRC

#+RESULTS:
: [nil 22945 64763 370655 nil alert-remove-when-active (alert-message-remove (:message "TEST" :title "config.org" :icon nil :severity normal :category nil :buffer #<buffer config.org> :mode org-mode :data nil)) nil 0]


Documentation for =alert=: https://github.com/jwiegley/alert

** TO-DOs

*** TODO Look at helm https://emacs-helm.github.io/helm/
